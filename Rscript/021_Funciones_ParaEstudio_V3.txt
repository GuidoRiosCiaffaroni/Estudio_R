# ────────────────────────────────────────────────────────────────────────────────
#  FUNCION: analiza_wp_upload()                                                 
#  Descripción: Realiza un análisis estadístico de la tabla `wp_db_upload`       
#  de WordPress, con filtros opcionales y generación de un gráfico 3D.          
#                                                                               
#  Parámetros                                                                    
#    edad      : NULL, num o vector num (valor único o rango c(min,max)).       
#    genero    : NULL o vector chr (ej.: "Femenino", "Masculino").             
#    comuna    : NULL o vector chr (ej.: "Santiago").                           
#    plot_3d   : Lógico. Si TRUE genera un scatterplot 3D (PNG).                
#    db_name   : Nombre de la BD (def. "wordpress").                            
#    host, user, password: credenciales BD.                                      
#    dir_out   : Carpeta salida (def. "/home/r/Estudio_R/salidas").             
#                                                                               
#  Retorna                                                                       
#    Lista con los data.frame de resultados (invisible).                        
# ────────────────────────────────────────────────────────────────────────────────

analiza_wp_upload <- function(edad      = NULL,
                              genero    = NULL,
                              comuna    = NULL,
                              plot_3d   = FALSE,
                              db_name   = "wordpress",
                              host      = "localhost",
                              user      = "nuevo_admin",
                              password  = "MiClaveSegura",
                              dir_out   = "/home/r/Estudio_R/salidas") {

#Filtros: edad, genero, comuna
#Opciones: plot_3d para crear gráfico
#Conexión DB: db_name, host, user, password
#Exportación: dir_out como carpeta de salida

  # ──────────────────────────────────────────────────────────────────
  #  Librerías -------------------------------------------------------
  # ──────────────────────────────────────────────────────────────────


  libs <- c("DBI", "RMariaDB", "dplyr", "tibble", "e1071", "broom", "scatterplot3d")
  inst <- libs[!libs %in% installed.packages()[, "Package"]]
  if (length(inst)) install.packages(inst)
  lapply(libs, library, character.only = TRUE)

# Verifica que los paquetes necesarios estén instalados, y si no, los instala. Luego los carga dinámicamente.
#"DBI": Proporciona una interfaz genérica para conectarse a bases de datos (Database Interface).
#"RMariaDB": Driver específico para conectarse a bases de datos MariaDB o MySQL desde R usando DBI.
#"dplyr": Parte del tidyverse; se usa para manipulación de datos (filtrar, agrupar, resumir, etc.).
#"tibble": Formato moderno de data frame, usado internamente por dplyr.
#"e1071": Contiene funciones estadísticas avanzadas, como asimetría (skewness) y curtosis (kurtosis).
#"broom": Convierte objetos de modelos estadísticos (como ANOVA o chi-cuadrado) a data frames ordenados ("tidy").




  # ──────────────────────────────────────────────────────────────────
  #  Conexión DB -----------------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  con <- dbConnect(RMariaDB::MariaDB(),
                   dbname   = db_name,
                   host     = host,
                   user     = user,
                   password = password,
                   timezone = "UTC")
  on.exit(dbDisconnect(con), add = TRUE)
  
#Conecta a la base de datos MariaDB y asegura que la conexión se cierre al finalizar.




  # ──────────────────────────────────────────────────────────────────
  #  Construcción de la consulta ------------------------------------
  # ──────────────────────────────────────────────────────────────────
  base_query <- "SELECT Edad, Nombre_Genero_Victima_Texto, Nombre_Comuna FROM wp_db_upload"
  clauses <- c()

# Consulta base para seleccionar las columnas necesarias. clauses se usará para agregar filtros condicionales.


  if (!is.null(edad)) {
    if (length(edad) == 2) {
      clauses <- c(clauses, sprintf("Edad BETWEEN %d AND %d", edad[1], edad[2]))
    } else {
      clauses <- c(clauses, sprintf("Edad = %d", edad[1]))
    }
  }
  
# Añade cláusula WHERE según si se pasa una edad única o un rango de edades.


  if (!is.null(genero)) {
    genero_quoted <- paste(sprintf("'%s'", genero), collapse = ",")
    clauses <- c(clauses, sprintf("Nombre_Genero_Victima_Texto IN (%s)", genero_quoted))
  }
	# Verifica si el parámetro genero no es NULL.
	# sprintf("'%s'", genero): envuelve cada valor en comillas simples, como lo requiere SQL. Por ejemplo: c("Femenino", "Masculino") se transforma en "'Femenino'", "'Masculino'".
	# paste(..., collapse = ","): une todos los valores en una sola cadena separada por comas:Resultado final: "‘Femenino’,‘Masculino’"
	# Agrega una cláusula SQL adicional a la lista clauses.   clauses <- c(clauses, sprintf("Nombre_Genero_Victima_Texto IN (%s)", genero_quoted))
  
  if (!is.null(comuna)) {
    comuna_quoted <- paste(sprintf("'%s'", comuna), collapse = ",")
    clauses <- c(clauses, sprintf("Nombre_Comuna IN (%s)", comuna_quoted))
  }
  
  # Añade cláusulas SQL para filtrar por género y comuna usando IN.
  
  query <- if (length(clauses)) paste(base_query, "WHERE", paste(clauses, collapse = " AND ")) else base_query

  datos <- dbGetQuery(con, query)

  # ──────────────────────────────────────────────────────────────────
  #  Funciones auxiliares -------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  moda <- function(x) {
    ux <- na.omit(unique(x)); ux[which.max(tabulate(match(x, ux)))]
  }
  
  # Calucla la moda 
  #  Define una función llamada moda, que toma como argumento un vector x.
  # unique(x): extrae los valores únicos del vector x.
  # na.omit(...): elimina los valores NA del conjunto anterior.
  # Resultado: ux contiene todos los valores distintos de x, sin NA.
  # match(x, ux): busca la posición de cada elemento de x en el vector ux.
  #Esto devuelve un vector de índices que representa a qué valor único pertenece cada valor original de x
  #tabulate(...): cuenta cuántas veces aparece cada índice (i.e., cuántas veces se repite cada valor único).
  #which.max(...): identifica la posición del valor más frecuente.
  # ux[ ... ]: devuelve el valor de ux que corresponde al índice con la mayor frecuencia.
  
  
  # Devuelve múltiples estadísticas descriptivas, incluyendo pruebas de normalidad (Shapiro-Wilk) si el tamaño lo permite.
  
  estadisticas_numericas <- function(vec) {
    vec <- na.omit(vec)
    tibble(
      media        = mean(vec),
      mediana      = median(vec),
      moda         = moda(vec),
      rango        = diff(range(vec)),
      q1           = quantile(vec, 0.25),
      q2           = quantile(vec, 0.50),
      q3           = quantile(vec, 0.75),
      sd           = sd(vec),
      varianza     = var(vec),
      ric          = IQR(vec),
      coef_var     = sd(vec) / mean(vec),
      asimetria    = e1071::skewness(vec),
      curtosis     = e1071::kurtosis(vec),
      shapiro_p    = ifelse(length(vec) >= 3 && length(vec) <= 5000,
                            shapiro.test(vec)$p.value, NA_real_))
  }

  # ──────────────────────────────────────────────────────────────────
  #  Estadísticos Edad ----------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  resumen_edad <- estadisticas_numericas(datos$Edad) %>% mutate(variable = "Edad")

# Llama a la función estadisticas_numericas() definida previamente en el script.
# El argumento entregado es datos$Edad, es decir, la columna Edad del data frame que se obtuvo de la base de datos.
#  El resultado es un tibble (data frame) con una fila y muchas columnas numéricas que resumen estadísticamente la variable Edad.
%>% mutate(variable = "Edad")
#Usa el operador pipe (%>%) de dplyr para encadenar operaciones.
#mutate(variable = "Edad"): añade una nueva columna llamada variable, cuyo valor será "Edad" en toda la fila.



  # Tablas de frecuencia
  freq_genero <- datos %>% dplyr::count(Nombre_Genero_Victima_Texto, name = "n") %>%
                 mutate(prop = n / sum(n))
  freq_comuna <- datos %>% dplyr::count(Nombre_Comuna, name = "n") %>%
                 mutate(prop = n / sum(n))
				 
				 
# Crea tablas de frecuencia y proporción para género y comuna.

# Se usa el operador pipe (%>%) para encadenar funciones de dplyr aplicadas al data frame datos, que proviene de la base de datos.
# Este datos contiene al menos las columnas: Edad, Nombre_Genero_Victima_Texto, y Nombre_Comuna.


# dplyr::count(Nombre_Genero_Victima_Texto, name = "n")
# Cuenta cuántas veces aparece cada valor distinto de Nombre_Genero_Victima_Texto, es decir, cada categoría de género.
# El argumento name = "n" indica que la columna del conteo se llamará n.
# Resultado parcial: un data frame con dos columnas:
# Nombre_Genero_Victima_Texto (e.g., "Femenino", "Masculino")
# n: cantidad de observaciones por género.
# %>% mutate(prop = n / sum(n))
# Agrega una nueva columna prop que representa la proporción relativa de cada categoría respecto del total.
# Se calcula como n / sum(n), es decir, frecuencia relativa.

  # ──────────────────────────────────────────────────────────────────
  #  Pruebas estadísticas -------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  chi_tbl <- table(datos$Nombre_Genero_Victima_Texto, datos$Nombre_Comuna)
	# table(...)
	# La función table() en R genera una tabla de contingencia, es decir, una matriz que cruza dos o más variables categóricas y cuenta las frecuencias conjuntas de sus combinaciones.
  
  chi_res <- broom::tidy(chisq.test(chi_tbl))
  
  
# Comentario detallado:
# chisq.test(chi_tbl)
# Ejecuta una prueba de chi-cuadrado de independencia sobre la tabla de contingencia chi_tbl.
# Evalúa si existe una asociación significativa entre dos variables categóricas: en este caso, género y comuna.
# Hipótesis:
# H₀ (nula): género y comuna son independientes.
# H₁ (alternativa): hay dependencia (el género se distribuye de forma distinta según la comuna).
# El resultado es un objeto de clase htest que contiene:
# Valor-p (p.value)
# Estadístico chi-cuadrado (statistic)
# Grados de libertad (parameter)
# Método usado
# Tabla esperada (expected), etc.
# broom::tidy(...)
# La función tidy() del paquete broom convierte objetos estadísticos complejos como los de chisq.test() en data frames ordenados y legibles (tibble).
# Esto facilita su inspección, exportación o visualización.
# Guarda este resumen ordenado (tidy) en el objeto chi_res, que luego es exportado como archivo CSV y puede ser analizado o visualizado.


  aov_res <- broom::tidy(aov(Edad ~ Nombre_Genero_Victima_Texto, data = datos))

# aov(Edad ~ Nombre_Genero_Victima_Texto, data = datos)
# Ejecuta un análisis de varianza (ANOVA) de un solo factor.
# Objetivo: determinar si hay diferencias estadísticamente significativas en la edad promedio según el género (Nombre_Genero_Victima_Texto).
# Edad ~ Nombre_Genero_Victima_Texto
# Significa que se está comparando la variable dependiente Edad entre los grupos definidos por la variable independiente Nombre_Genero_Victima_Texto.
# La función aov() retorna un objeto de clase aov, que contiene:
# Sumatoria de cuadrados (SS)
# Grados de libertad (Df)
# Media cuadrática (MS)
# Estadístico F
# Valor-p
# broom::tidy(...)
# Transforma el objeto aov en un tibble ordenado (tabla), gracias al paquete broom.
# Esto permite acceder fácilmente a los resultados del ANOVA en formato data frame para su inspección o exportación.
# aov_res <- ...
# Guarda el resultado del ANOVA en formato tidy en el objeto aov_res, que luego será exportado a un archivo CSV.

  
#  Prueba chi-cuadrado para evaluar independencia entre género y comuna.

  # ──────────────────────────────────────────────────────────────────
  #  Salida de gráficos 3D ------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  if (plot_3d) {
    if (!dir.exists(dir_out)) dir.create(dir_out, recursive = TRUE)
    png(file.path(dir_out, "plot3d_edad_genero_comuna.png"), width = 900, height = 700)
    scatterplot3d::scatterplot3d(x    = as.numeric(factor(datos$Nombre_Genero_Victima_Texto)),
                                y    = as.numeric(factor(datos$Nombre_Comuna)),
                                z    = datos$Edad,
                                pch  = 16,
                                highlight.3d = TRUE,
                                xlab = "Género (factor)",
                                ylab = "Comuna (factor)",
                                zlab = "Edad")
    dev.off()
  }


# if (plot_3d) {
# Evalúa si el argumento plot_3d fue establecido en TRUE.
# Si es así, se procederá a generar y guardar un gráfico tridimensional (3D).
# Esto permite que el gráfico se cree solo si el usuario lo solicita explícitamente.
# if (!dir.exists(dir_out)) dir.create(dir_out, recursive = TRUE)
# Verifica si la carpeta de salida dir_out existe.
# Si no existe, la crea (incluyendo subdirectorios si es necesario, gracias a recursive = TRUE).
# png(file.path(dir_out, "plot3d_edad_genero_comuna.png"), width = 900, height = 700)
# Abre un dispositivo gráfico de tipo PNG para guardar el gráfico 3D en un archivo llamado plot3d_edad_genero_comuna.png, dentro de la carpeta de salida.
# Establece las dimensiones de la imagen: 900x700 píxeles.
#  scatterplot3d::scatterplot3d(
#    x = as.numeric(factor(datos$Nombre_Genero_Victima_Texto)),
#    y = as.numeric(factor(datos$Nombre_Comuna)),
#    z = datos$Edad,
#    pch = 16,
#    highlight.3d = TRUE,
#    xlab = "Género (factor)",
#    ylab = "Comuna (factor)",
#    zlab = "Edad"
#  )
# Llama a la función scatterplot3d() del paquete scatterplot3d para dibujar el gráfico tridimensional con los siguientes ejes:
# x: género, convertido a número con as.numeric(factor(...)) (p.ej., "Femenino" → 1, "Masculino" → 2).
#
# y: comuna, también convertida a número (para poder graficarse).
# z: edad (variable numérica continua).
# pch = 16: tipo de punto sólido.
# highlight.3d = TRUE: activa el sombreado según la profundidad (mejora percepción visual del eje z).
# xlab, ylab, zlab: etiquetas para cada eje.
# Este gráfico permite visualizar cómo se distribuyen las edades por género y comuna.
#  dev.off()
# Cierra el dispositivo gráfico PNG, guardando efectivamente la imagen en disco.



# Si plot_3d = TRUE, genera un gráfico de dispersión 3D guardado en PNG.


  # ──────────────────────────────────────────────────────────────────
  #  Exportación -----------------------------------------------------
  # ──────────────────────────────────────────────────────────────────
  if (!dir.exists(dir_out)) dir.create(dir_out, recursive = TRUE)



# Comentario detallado:
# dir.exists(dir_out)
# Comprueba si existe un directorio en la ruta especificada por dir_out.
# dir_out es una variable que representa la carpeta de salida donde se guardarán archivos (gráficos, CSV, etc.).
# Esta función devuelve TRUE si la carpeta existe, y FALSE si no.
# !dir.exists(dir_out)
# El operador ! niega el resultado.
# Es decir, la condición se cumple solo si el directorio NO existe.
# dir.create(dir_out, recursive = TRUE)
# Si el directorio no existe, lo crea con dir.create().
# El argumento recursive = TRUE indica que si hay subdirectorios en la ruta, también deben crearse automáticamente si no existen.
# Ejemplo: si dir_out = "salidas/analisis/julio" y solo existe salidas, esta opción asegura que se creen también analisis y julio.

  write.csv(datos,         file.path(dir_out, "datos_filtrados.csv"),       row.names = FALSE)
  write.csv(resumen_edad,  file.path(dir_out, "edad_resumen.csv"),          row.names = FALSE)
  write.csv(freq_genero,   file.path(dir_out, "frecuencia_genero.csv"),     row.names = FALSE)
  write.csv(freq_comuna,   file.path(dir_out, "frecuencia_comuna.csv"),     row.names = FALSE)
  write.csv(chi_res,       file.path(dir_out, "chi_genero_comuna.csv"),     row.names = FALSE)
  write.csv(aov_res,       file.path(dir_out, "anova_edad_genero.csv"),     row.names = FALSE)



# Comentario paso a paso:
# write.csv(...)
# Es una función base de R que escribe un data frame en un archivo CSV (valores separados por comas).
# Este formato es ampliamente utilizado para guardar y compartir datos tabulares, especialmente en análisis reproducibles.
# aov_res
# Es el data frame que contiene los resultados del ANOVA (análisis de varianza) aplicado a la variable Edad según el género (Nombre_Genero_Victima_Texto).
# Este objeto fue generado previamente con:


# Guarda en archivos .csv todos los resultados: datos, estadísticas, frecuencias, chi-cuadrado y ANOVA.


  message(" Análisis completo. Resultados y gráficos en: ", normalizePath(dir_out))
  invisible(list(datos = datos,
                 resumen_edad = resumen_edad,
                 freq_genero = freq_genero,
                 freq_comuna = freq_comuna,
                 chi_res = chi_res,
                 aov_res = aov_res))
}

# ───────────────────────────────────────────────────────────────────────────────
#  EJEMPLOS DE USO -------------------------------------------------------------
#                                                                          
# 1) Análisis completo sin filtros + gráfico 3D
 analiza_wp_upload(plot_3d = TRUE)
#
# 2) Filtro género y comuna, sin gráfico
# analiza_wp_upload(genero = "Femenino", comuna = "Santiago")
#
# 3) Edad entre 20 y 40, con gráfico
# analiza_wp_upload(edad = c(20,40), plot_3d = TRUE)
# ───────────────────────────────────────────────────────────────────────────────
#  FIN -------------------------------------------------------------------------
